GATES
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity gates is
 Port ( a : in STD_LOGIC; 
 b : in STD_LOGIC; 
 y_not : out STD_LOGIC;
 y_and : out STD_LOGIC;
 y_or : out STD_LOGIC;
 y_nand : out STD_LOGIC;
 y_nor : out STD_LOGIC;
 y_xor : out STD_LOGIC;
 y_xnor : out STD_LOGIC);
end gates;
architecture Behavioral of gates is
begin
 y_not <= not a;
 y_and <= a and b;
 y_or <= a or b;
 y_nand <= a nand b;
 y_nor <= a nor b;
 y_xor <= a xor b;
 y_xnor <= a xnor b;
end Behavioral;
___________________________________________________________________________
GATES BUS
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity gates_bus is
 Port ( a : in STD_LOGIC;
 b : in STD_LOGIC;
 Y : out STD_LOGIC_VECTOR (6 downto 0));
end gates_bus;
architecture Behavioral of gates_bus is
begin
 Y(6) <= not a;
 Y(5) <= a and b;
 Y(4) <= a or b;
 Y(3) <= a nand b;
 Y(2) <= a nor b;
 Y(1) <= a xor b;
 Y(0) <= a xnor b; 
end Behavioral;
___________________________________________________________________________
POS https://charlie-coleman.com/experiments/kmap/
___________________________________________________________________________
1
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity vhdl_01_2 is
 Port (a : in STD_LOGIC;
 b : in STD_LOGIC;
 c : in STD_LOGIC;
 d : in STD_LOGIC;
 f : out STD_LOGIC );
end vhdl_01_2;
architecture Behavioral of vhdl_01_2 is
begin
 process (a, b, c, d)
 begin
 f <= ((a or b or (not c) or d) and (a or (not b) or c or d) 
 and (a or (not b) or (not c) or (not d))
 and ((not a) or b or (not c) or (not d)));
 end process;
end Behavioral;
___________________________________________________________________________
SIGNALS
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity signals is
 Port ( a3, a2, a1, a0 : in STD_LOGIC;
 b3, b2, b1, b0 : in STD_LOGIC;
 y : out STD_LOGIC);
end signals;
architecture Behavioral_1 of signals is
begin
 y <= (a3 xnor b3) and (a2 xnor b2) and (a1 xnor b1) and (a0 xnor b0); 
end Behavioral_1;
___________________________________________________________________________
SOP https://charlie-coleman.com/experiments/kmap/
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity sop is
 Port ( a : in STD_LOGIC; 
 b : in STD_LOGIC;
 c : in STD_LOGIC; 
 d : in STD_LOGIC;
 y : out STD_LOGIC);
end sop;
architecture Behavioral of sop is
begin
 y <= (not a and not b and c and not d) or (not a and not b and c and d) or (not a and b and 
not c and d) or (not a and b and c and not d) or (not a and b and c and d) or (a and not b and 
2
not c and not d) or (a and not b and not c and d) or (a and not b and c and d) or (a and b and 
not c and not d) or (a and b and not c and d) or (a and b and c and not d) or (a and b and c 
and d);
end Behavioral;
___________________________________________________________________________
mx4_WHEN_ELSE
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity mx4_1_when_else is
 Port ( D : in STD_LOGIC_VECTOR (3 downto 0);
 S : in STD_LOGIC_VECTOR (1 downto 0);
 y : out STD_LOGIC);
end mx4_1_when_else;
architecture Behavioral of mx4_1_when_else is
begin
 y <= D(0) when S = "00" else
 D(1) when S = "01" else
 D(2) when S = "10" else
 D(3) when S = "11";
-- Vedie na syntézu KLO MUX s kaskádnym zapojením
-- y <= D(0) when S = "00" else
-- D(1) when S = "01" else
-- D(2) when S = "10" else
-- D(3);
end Behavioral;
___________________________________________________________________________
SHIFTER
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity shifter is
 Port ( X : in STD_LOGIC_VECTOR (3 downto 0);
 Mode : in STD_LOGIC_VECTOR (1 downto 0);
 Y : out STD_LOGIC_VECTOR (3 downto 0));
end shifter;
architecture Behavioral of shifter is
 constant SHTL : std_logic_vector(1 downto 0) := "00";
 constant ROTL : std_logic_vector(1 downto 0) := "01";
 constant SHTR : std_logic_vector(1 downto 0) := "10";
 constant ROTR : std_logic_vector(1 downto 0) := "11";
 component mx4_1_with_select is
 Port ( D : in STD_LOGIC_VECTOR (3 downto 0);
 S : in STD_LOGIC_VECTOR (1 downto 0);
 y : out STD_LOGIC);
 end component mx4_1_with_select;
 signal Mx3, Mx2, Mx1, Mx0 : std_logic_vector(3 downto 0);
begin
3
 Mx3 <= X(0) & '0' & X(2) & X(2);
MUX3: mx4_1_with_select PORT MAP ( 
 D => Mx3,
 S => Mode,
 y => Y(3)
 );
 Mx2 <= X(3) & X(3) & X(1) & X(1);
MUX2: mx4_1_with_select PORT MAP ( 
 D => Mx2,
 S => Mode,
 y => Y(2)
 );
 Mx1 <= X(2) & X(2) & X(0) & X(0);
MUX1: mx4_1_with_select PORT MAP ( 
 D => Mx1,
 S => Mode,
 y => Y(1)
 );
 Mx0 <= X(1) & X(1) & X(3) & '0';
MUX0: mx4_1_with_select PORT MAP ( 
D => Mx0,
 S => Mode,
y => Y(0)
 ); 
end Behavioral;
___________________________________________________________________________
GRAY_TO_BCD
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity gray_to_bcd is
 Port ( g1 : in STD_LOGIC;
 g2 : in STD_LOGIC;
 g3 : in STD_LOGIC;
 g4 : in STD_LOGIC;
 a : out STD_LOGIC; 
 b : out STD_LOGIC; 
 c : out STD_LOGIC;
 d : out STD_LOGIC); 
end gray_to_bcd;
architecture Behavioral of gray_to_bcd is
begin 
 a <= g1;
 b <= not g1 and g2;
 c <= (not g1 and g2 and not g3) or (not g2 and g3);
 d <= (g1 and g4) or (not g1 and g2 and not g3 and not g4) or (g2 and g3 and g4) or (not g2 
and g3 and not g4) or (not g2 and not g3 and g4) ;
end Behavioral;
___________________________________________________________________________
4
BCD_TO_GRAY
___________________________________________________________________________
library ieee;
use ieee.std_logic_1164.all;
entity bcd_to_gray is
port (b : in std_logic_vector(3 downto 0);
 g : out std_logic_vector(3 downto 0));
end bcd_to_gray;
architecture bcd_to_gray of bcd_to_gray is
begin
 g(3) <= b(3);
 g(2) <= b(3) xor b(2);
 g(1) <= b(2) xor b(1);
 g(0) <= b(1) xor b(0);
 end bcd_to_gray;
___________________________________________________________________________
MX4_WITH_SELECT
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity mx4_1_with_select is
 Port ( D : in STD_LOGIC_VECTOR (3 downto 0);
 S : in STD_LOGIC_VECTOR (1 downto 0);
 y : out STD_LOGIC);
end mx4_1_with_select;
architecture Behavioral of mx4_1_with_select is
begin
with S select
 y <= D(0) when "00",
 D(1) when "01",
 D(2) when "10",
 D(3) when others;
end Behavioral
___________________________________________________________________________
NUMBER_REPRESENTATION
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
entity number_representation is
 Port ( sign : in STD_LOGIC; 
 Magnitude : in STD_LOGIC_VECTOR (6 downto 0); 
 Signed_magnitude : out STD_LOGIC_VECTOR (7 downto 0); 
 Ones_complement : out STD_LOGIC_VECTOR (7 downto 0);
 Twos_complement : out STD_LOGIC_VECTOR (7 downto 0));
end number_representation;
architecture Behavioral of number_representation is
5
 signal Tmp : std_logic_vector(7 downto 0);
begin
 Signed_magnitude <= sign & Magnitude;
 Tmp <= ('0' & Magnitude) when sign = '0' else ('1' & not(Magnitude));
 Ones_complement <= Tmp;
 Twos_complement <= Tmp when sign = '0' else std_logic_vector(unsigned(Tmp)+1);
end Behavioral;
___________________________________________________________________________
CONCURRENT_SIGNAL_ASSIGNMENT
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity concurrent_signal_assignment is
 Port ( a,b,c : in STD_LOGIC;
 y : out STD_LOGIC);
end concurrent_signal_assignment;
architecture Behavioral of concurrent_signal_assignment is
signal not_a_and_not_B : STD_LOGIC;
signal not_b_and_not_c : STD_LOGIC;
signal a_and_b_and_c : STD_LOGIC;
begin
 not_a_and_not_B <= (not a) and (not b); 
 not_b_and_not_c <= (not b) and (not c); 
 a_and_b_and_c <= a and b and c; 
 y <= not_a_and_not_B or not_b_and_not_c or a_and_b_and_c;
end Behavioral;
___________________________________________________________________________
RIPPLE_CARRY_ADDER
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity ripple_carry_adder is
 generic(width : positive := 4);
 Port ( A, B : in STD_LOGIC_VECTOR (width-1 downto 0);
 Sum : out STD_LOGIC_VECTOR (width-1 downto 0);
 carry : out STD_LOGIC);
end ripple_carry_adder;
architecture Behavioral of ripple_carry_adder is
 component half_adder is
 Port ( a, b : in STD_LOGIC;
 sum : out STD_LOGIC;
 carry : out STD_LOGIC);
 end component half_adder;
 component full_adder is
 Port ( a, b, c : in STD_LOGIC;
 sum : out STD_LOGIC;
 carry : out STD_LOGIC);
 end component full_adder;
6
signal C : std_logic_vector(width-1 downto 0);
begin
RCA : for i in 0 to width-1 generate
LSB : if i = 0 generate
ADD0 : half_adder port map (a => A(0), b => B(0), sum => SUM(0), 
carry => C(0));
end generate LSB;
UPPER_BITS : if i > 0 generate
ADDX : full_adder port map (a => A(i), b => B(i), c => C(i-1), sum => 
SUM(i), carry => C(i));
end generate UPPER_BITS;
end generate RCA;
carry <= C(width-1);
end Behavioral;
___________________________________________________________________________
HALF_ADDER
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity half_adder is
 Port ( a, b : in STD_LOGIC;
 sum : out STD_LOGIC;
 carry : out STD_LOGIC);
end half_adder;
architecture Behavioral of half_adder is
begin
sum <= a xor b;
carry <= a and b;
end Behavioral;
___________________________________________________________________________
FULL_ADDER
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity full_adder is
 Port ( a, b, c : in STD_LOGIC;
 sum : out STD_LOGIC;
 carry : out STD_LOGIC);
end full_adder;
architecture Behavioral of full_adder is
begin
sum <= (a xor b) xor c;
carry <= (a and b) or ((a xor b) and c);
end Behavioral;
___________________________________________________________________________
WIDE_AND
___________________________________________________________________________
library IEEE;
7
use IEEE.STD_LOGIC_1164.ALL;
entity wide_and is
 generic (width : positive := 32); 
 Port ( Data : in STD_LOGIC_VECTOR (width-1 downto 0); 
 y : out STD_LOGIC); 
end wide_and;
architecture Behavioral of wide_and is
signal Tmp_data : std_logic_vector(width-1 downto 0);
begin
 Tmp_data(0) <= Data(0);
 WAND : for i in 1 to width-1 generate
 Tmp_data(i) <= Tmp_data(i-1) and Data(i);
 end generate WAND;
 y <= Tmp_data(width-1);
end Behavioral;
___________________________________________________________________________
IF_GENERATE
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity if_generate is
 generic(sel : natural := 0);
 Port ( a, b, c, d : in STD_LOGIC;
 y : out STD_LOGIC);
end if_generate;
architecture Behavioral of if_generate is
begin
 AND_DATA : if sel = 0 generate
 y <= (((a and b) and c) and d);
 end generate; 
 OR_DATA : if sel = 1 generate
 y <= (((a or b) or c) or d);
 end generate;
 NAND_DATA : if sel = 2 generate
 y <= (((a nand b) nand c) nand d);
 end generate; 
 NOR_DATA : if sel = 3 generate
 y <= (((a nor b) nor c) nor d);
 end generate; 
 XOR_DATA : if sel = 4 generate
 y <= (((a xor b) xor c) xor d);
 end generate; 
 XNOR_DATA : if sel >= 5 generate
 y <= (((a xnor b) xnor c) xnor d);
 end generate;
end Behavioral;
___________________________________________________________________________
mult_5x5u_5x5u 
8
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
library UNISIM;
use UNISIM.VComponents.all;
entity mult_5x5u_5x5u is
 Port ( X2, Y2 : in STD_LOGIC_VECTOR (4 downto 0); --high-order bits
 X1, Y1 : in STD_LOGIC_VECTOR (4 downto 0); --low-order bits
 XY2 : out STD_LOGIC_VECTOR (9 downto 0); --high-order bits 
 XY1 : out STD_LOGIC_VECTOR (9 downto 0));--low-order bits
end mult_5x5u_5x5u;
architecture Behavioral of mult_5x5u_5x5u is
 signal A, B : std_logic_vector(17 downto 0);
 signal P : std_logic_vector(35 downto 0);
begin
 A(17 downto 12) <= '0' & X2;
 A(11 downto 5) <= (others => '0');
 A(4 downto 0) <= X1;
 B(17 downto 12) <= '0' & Y2;
 B(11 downto 5) <= (others => '0');
 B(4 downto 0) <= Y1;
 MULT18X18_inst : MULT18X18 port map (
 P => P,
 A => A,
 B => B
 );
 XY2 <= P(33 downto 24);
 XY1 <= P(9 downto 0);
end Behavioral;
___________________________________________________________________________
MULTIPLIER
___________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
library UNISIM;
use UNISIM.VComponents.all;
entity multiplier is
 Port ( A, B : in STD_LOGIC_VECTOR (17 downto 0); 
 P : out STD_LOGIC_VECTOR (35 downto 0)); 
end multiplier;
architecture Structural of multiplier is
begin 
 MULT18X18_inst : MULT18X18 port map (
 P => P, 
 A => A, 
 B => B 
 );
end Structural;
9
___________________________________________________________________________
PARITY_GENERATOR
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity partity_generator is
 generic (width : natural := 8);
 Port(D : in STD_LOGIC_VECTOR(width-1 downto 0);
 parity : out STD_LOGIC);
end partity_generator;
architecture Behavioral of partity_generator is
 signal buff : STD_LOGIC_VECTOR (width-1 downto 0);
begin
 buff(0) <= '0' xor D(0);
 forloop: for i in 1 to (width - 1) generate
 buff(i) <= buff(i-1) xor D(i); 
 end generate;
 parity <= buff(width - 1);
end Behavioral
_________________________________________________________________________
RS_NOR
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity rs_nor is
 Port ( R : in STD_LOGIC;
 S : in STD_LOGIC;
 Q : inout STD_LOGIC;
 Qbar : inout STD_LOGIC);
end rs_nor;
architecture Behavioral of rs_nor is
begin
 Q <= Qbar nor R;
 Qbar <= Q nor S; 
end Behavioral;
_________________________________________________________________________
RS_NAND
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity rs_nand is
Port (
 r,s: in STD_LOGIC;
 q,qb : inout STD_LOGIC
 );
end rs_nand;
10
architecture rs_nand_arch of rs_nand is
signal tmp_q, tmp_qb : STD_LOGIC;
begin
tmp_q <= s NAND tmp_qb;
tmp_qb <= r NAND tmp_q;
q <= tmp_q;
qb <= tmp_qb;
end rs_nand_arch;
_________________________________________________________________________
COUNTER
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
entity counter is
 generic (up_counter : boolean := TRUE;
 width : positive := 8; 
 init_value : natural := 0);
 Port ( clk : in STD_LOGIC;
 rst : in STD_LOGIC;
 en : in STD_LOGIC;
 Y : out STD_LOGIC_VECTOR (width-1 downto 0);
 o : out STD_LOGIC);
end counter;
architecture Behavioral of counter is
begin
 process(clk, rst)
 variable cnt : unsigned(width-1 downto 0) := (others => '0'); 
 begin
 if rising_edge(clk) then
 if (rst = '1') then
 cnt := to_unsigned(init_value, Y'length);
 o <= '0';
 else
 if (en = '1') then
 if up_counter then 
 cnt := cnt + 1;
 else
 cnt := cnt - 1; 
 end if;
 if (cnt = 0) then
 o <= '1';
 else
 o <= '0';
 end if;
 end if;
 end if;
 end if;
 Y <= std_logic_vector(cnt);
11
 end process; 
end Behavioral;
_________________________________________________________________________
SEVEN_SEG_DECODER
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity seven_seg_decoder is
 Port ( Data : in STD_LOGIC_VECTOR (3 downto 0);
 Segments : out STD_LOGIC_VECTOR (6 downto 0));
end seven_seg_decoder;
architecture Behavioral of seven_seg_decoder is
begin
 process(Data) begin
 case Data is
 when X"0" => Segments <= "1111110";
 when X"1" => Segments <= "0110000";
 when X"2" => Segments <= "1101101";
 when X"3" => Segments <= "1111001";
 when X"4" => Segments <= "0110011";
 when X"5" => Segments <= "1011011";
 when X"6" => Segments <= "1011111";
 when X"7" => Segments <= "1110000";
 when X"8" => Segments <= "1111111";
 when X"9" => Segments <= "1110011";
 when others => Segments <= "0000000";
 end case;
 end process;
end Behavioral;
_________________________________________________________________________
D_LATCH
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity d_latch is
 Port ( d : in STD_LOGIC;
 en : in STD_LOGIC;
 q : out STD_LOGIC);
end d_latch;
architecture Behavioral of d_latch is
begin
 DFF_LATCH_EN: process(d, en) is
 begin
 if (en = '1') then
 q <= d;
 end if; 
 end process;
12
end Behavioral;
_________________________________________________________________________
DFF
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity dff is
 Port ( clk : in STD_LOGIC;
 d : in STD_LOGIC; 
 q : out STD_LOGIC);
end dff;
architecture Behavioral of dff is
begin
DFF_UP: process(clk) is
begin
if rising_edge(clk) then
q <= d;
end if;
end process;
end Behavioral;
_________________________________________________________________________
DFF_EN
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity dff_en is
 Port ( clk : in STD_LOGIC;
 rst : in STD_LOGIC; 
 d : in STD_LOGIC;
 en : in STD_LOGIC; 
 q : out STD_LOGIC);
end dff_en;
architecture Behavioral of dff_en is
begin
 DFF_UP_RST_EN: process(clk) is
 begin
 if rising_edge(clk) then
 if (rst = '1') then
 q <= '0';
 elsif en = '1' then
 q <= d;
 end if; 
 end if;
 end process;
end Behavioral;
_________________________________________________________________________
MX4_CASE
_________________________________________________________________________
13
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity mx4_1_case is
 Port ( D : in STD_LOGIC_VECTOR (3 downto 0);
 S : in STD_LOGIC_VECTOR (1 downto 0);
 y : out STD_LOGIC);
end mx4_1_case;
architecture Behavioral of mx4_1_case is
begin
 process (D,S) 
 begin
 case S is
 when "00" => y <= D(0);
 when "01" => y <= D(1);
 when "10" => y <= D(2);
 when "11" => y <= D(3);
 when others => null;
 end case; 
 end process;
end Behavioral
_________________________________________________________________________
MX8_SELECT
_________________________________________________________________________
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity max is
 Port (D : in STD_LOGIC_VECTOR(7 to 0);
 S : in STD_LOGIC_VECTOR(2 to 0);
 y : out STD_LOGIC);
end max;
architecture Behavioral of max is
begin
 with S select
 y <= D(0) when "000",
 D(1) when "001",
 D(2) when "010",
 D(3) when "011",
 D(4) when "100",
 D(5) when "101",
 D(6) when "110",
 D(7) when "111";
end Behavioral;
_________________________________________________________________________
14
15
